# LAB8 实验报告

## 练习1: 完成读文件操作的实现

### 实现方法

需要完成`sfs_inode.c`中的`sfs_io_nolock`函数. 对于读取内容中落在整个block的部分, 使用`sfs_block_op`读取, 对于非对齐的部分使用`sfs_buf_op`读取.

### PIPE机制的概要设计方案

shell解析管道命令, 在内存中创建一个临时区域存储管道的内容, 同时在文件系统中提供特定的文件描述符用来对该区域进行操作. 父进程打开管道文件得到其描述符, 创建的子进程可以获得同一个描述符从而使用同一个管道文件进行通信.

## 练习2: 完成基于文件系统的执行程序机制的实现

### 实现方法

需要实现`proc.c`中的`load_icode`函数. 该函数在之前的实验中已经提供框架, 但之前的版本是直接从指定的内存地址处读入elf文件, 本实验中只需要将读内存的操作替换为读文件的操作即可. 读文件的函数已提供, 为`load_icode_read`.

具体做法为将原来的`memcpy`等函数替换为`load_icode_read`函数, 同时在运行栈上开辟存储elf header和prog header的临时空间. 其余步骤与之前的实验大多相同.

注意到本次实验增加了传递参数argc, argv的要求, 故需要把参数拷贝到用户态运行栈上, 从低到高依次为argc, argv[]中的所有地址和argv[]中所有地址指向的字符串内容. 这样就构造好了用户态程序主函数运行前的栈空间.

### 硬链接和软链接机制的概要设计方案

- 硬链接: 对每个inode设置一个链接计数器, 创建硬链接时该文件数据块中的inode和data block与源文件均相同, 同时链接计数+1, 删除时链接计数-1, 若计数变为0则删除文件.
- 软链接: 分配一个新的inode和data block, 但其中的内容为源文件路径名的指向.

## 与参考答案的区别

练习1拷贝整块的block时我直接一次拷贝了n块, 而答案使用循环每次拷贝1块.

## 实验中重要的知识点及其与OS原理的对应

- 读文件操作的实现: 对应原理中文件系统的功能.
- 执行程序机制的实现: 对应原理中进程创建与切换, 进程地址空间, elf文件格式, 异常处理.
