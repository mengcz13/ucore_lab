# 操作系统LAB4

## 练习1: 分配并初始化一个进程控制块

### 设计实现过程

将`proc_state`中的成员变量设置好即可. 对于刚刚创建的内核线程, `state`设为`PROC_UNINIT`, `cr3`设为内核页目录基址`boot_cr3`. 其余变量初始化为0或者调用默认的初始化函数即可, 在后面用到时会进行修改.

### 回答问题

`proc_struct`中`struct context context`含义为内核线程进行切换前一刻的运行上下文, 保存了`eip`, `esp`和其他的通用寄存器. 在本实验中的作用是记录线程上下文以方便切换.

`proc_struct`中`struct trapframe *tf`的含义为执行线程切换时异常栈的内容, 在实验中的作用是提供从中断处理返回时需要修改的信息. 例如在使用fork创建新进程时, 通过修改tf的信息, 可以使得该系统调用在父进程和子进程中返回不同的值. 通过修改tf中esp可以实现运行栈的切换.

## 练习2: 为新创建的内核线程分配资源

### 设计实现过程

调用`alloc_proc`创建进程控制块, 为新线程分配id, 内核栈空间, 复制当前线程内存, 设置trapframe和运行栈. 设置完成后将新线程加入hash队列和普通队列. 最后返回被创建线程的pid.

### 回答问题

- ucore是否做到给每个新fork的线程一个唯一的id?

是的. 详见`get_pid`函数, 该函数每次调用均返回上次pid+1的值. 特别地, 当pid+1与已有pid重复时, 会跳过重复的pid, 同时`next_safe`会调整为下一个进程的pid或者调整为最大pid.

## 练习3: 阅读代码, 理解`proc_run`函数和它调用的函数如何完成进程切换的

### 对`proc_run`函数的分析

proc函数首先完成对current的修改, 对tss的esp0的修改和cr3寄存器的修改. 修改完cr3寄存器之后即切换到了下一个进程. 切换之后执行`switch_to`恢复执行现场, 包括通用寄存器和esp, eip的恢复.

### 在本实验的执行过程中创建并运行了几个内核线程?

2个, 分别是idle和init. 其中idle是启动后运行的内核线程, 相当于在运行之后加的一个外壳. init打印`Hello World!!`后退出.

### 语句`local_intr_save(intr_flag); ... local_intr_restore(intr_flag);`在这里有何作用?

2个语句分别用来关中断和开中断. 切换进程过程中应当关闭对外界中断的响应, 防止在切换过程中因为响应外部中断而破坏切换过程中用到的trapframe.
