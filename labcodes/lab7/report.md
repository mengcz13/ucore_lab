# LAB7 实验报告

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

### 内核级信号量的设计和执行流程

内核级信号量在`kern/sync/sem.h`中的`struct semaphore_t`被定义, 包括信号量值`value`和等待队列`wait_queue`.

信号量的接口包括:

- 初始化函数`sem_init`.
- V操作函数`up`.
    执行时若当前信号量等待队列为空则增加信号量值, 否则唤醒等待队列中第一个进程.
- P操作函数`down`.
    执行时若信号量值>0则将其-1, 否则当前进程加入等待队列并放弃CPU, 执行调度.

### 用户态进程/线程信号量机制的设计方案

用户态的信号量机制可以借助系统调用+内核信号量实现. 内核负责信号量的创建, 管理和PV操作, 同时提供相应的系统调用.

- 初始化: 使用系统调用在内核分配一个信号量的空间, 返回信号量的id.
- V函数: 传入信号量id, 由系统调用在内核执行V操作.
- P函数: 传入信号量id, 由系统调用在内核执行P操作.

内核部分的操作与内核态信号量相同, 但由于用户态无法直接通过开关中断实现原子操作, 故需要通过系统调用切换到内核态执行.

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 内核级条件变量的设计描述和大致执行流流程

内核级条件变量在`kern/sync/monitor.h`中的`struct condvar`被定义, 基于信号量实现, 包括信号量sem, 等待计数count和对应的monitor指针owner. 其中sem起到了等待队列的作用, owner中的信号量则起到了锁的作用. monitor中的next上的进程为发出signal的进程, monitor中的mutex为管程的互斥锁.

条件变量的接口包括:

- `cond_wait`
    当前条件变量的等待计数+1, 之后分2种情况处理: 若mt中已有发出signal的进程(对应next_count>0)则唤醒; 否则(对应next_count<=0)应当唤醒因互斥锁而无法进入管程的进程. 然后当前进程在sem上wait, 加入等待队列. 被唤醒后当前条件变量等待计数-1, 返回.
- `cond_signal`
    若当前条件变量上无进程等待(count==0)则直接返回即可, 否则需要继续. next_count+1, 唤醒sem等待队列中的进程, 然后在mt.next上等待, 被唤醒后next_count-1.

同时在管程的入口和出口处应当有必要的操作保证信号量的正常释放. 首先进入管程前要获取互斥锁, 其次在离开时要判断当前是否还有因执行了`cond_signal`而睡眠的进程, 若有则需要唤醒, 若无则直接释放互斥锁.

### 用户态进程/线程提供条件变量机制的设计方案

可以仿照内核态条件变量机制实现. 由于ucore中通过信号量实现了条件变量, 故在用户态实现了信号量之后即可按照内核的实现方法在用户态实现条件变量.

实现方法与内核态的条件变量相同, 但其中使用的信号量是用户态的信号量, 对其操作均需要通过系统调用完成.

## 与参考实现的区别

无

## 本实验中重要的知识点以及对应的OS原理的知识点

信号量的实现, 对应OS原理中的信号量和原子操作. 实验中通过开关中断实现了信号量操作的原子性.

条件变量的实现, 对应OS原理中的管程与条件变量.

## 实验中没有对应的知识点

自旋锁, 死锁的预防/避免/检测.
